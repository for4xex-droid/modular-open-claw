//! # ドメイントレイト定義
//!
//! ShortsFactory の4つのツールモジュールのインターフェースを定義する。
//! 具体実装は `libs/infrastructure` に配置する（依存性逆転の原則）。

use crate::error::FactoryError;
use crate::contracts::OracleVerdict;
use async_trait::async_trait;
use std::path::PathBuf;

/// トレンド調査ツール (TrendSonar)
///
/// X, Google Trends, 5ch 等から今バズっているテーマを取得する。
#[async_trait]
pub trait TrendSource: Send + Sync {
    /// 指定カテゴリのトレンドキーワードを取得
    async fn get_trends(&self, category: &str) -> Result<Vec<TrendItem>, FactoryError>;
}

/// トレンド情報の1件分
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct TrendItem {
    /// キーワード
    pub keyword: String,
    /// ソース (例: "X", "GoogleTrends", "5ch")
    pub source: String,
    /// スコア (高いほど注目度が高い)
    pub score: f64,
}

/// 動画生成ツール (ComfyBridge)
///
/// ComfyUI API を通じて画像/動画を生成する。
#[async_trait]
pub trait VideoGenerator: Send + Sync {
    /// ワークフローを実行し、生成されたファイルのパスを返す
    async fn generate_video(
        &self,
        prompt: &str,
        workflow_id: &str,
        input_image: Option<&std::path::Path>,
    ) -> Result<crate::contracts::VideoResponse, FactoryError>;

    /// ComfyUI の接続状態を確認
    async fn health_check(&self) -> Result<bool, FactoryError>;
}

/// メディア編集ツール (MediaForge)
///
/// FFmpeg を使って動画・音声・字幕を合成する。
#[async_trait]
pub trait MediaEditor: Send + Sync {
    /// 動画、音声、字幕を合成して最終出力を生成
    async fn combine_assets(
        &self,
        video: &PathBuf,
        audio: &PathBuf,
        subtitle: Option<&PathBuf>,
        force_style: Option<String>,
    ) -> Result<PathBuf, FactoryError>;

    /// 動画をショート用にリサイズ (9:16, 1080x1920)
    async fn resize_for_shorts(&self, input: &PathBuf) -> Result<PathBuf, FactoryError>;

    /// 複数のメディアクリップを 1つのファイルに結合
    async fn concatenate_clips(&self, clips: Vec<String>, output_name: String) -> Result<String, FactoryError>;

    /// メディアファイルの尺長（秒）を取得する
    async fn get_duration(&self, path: &std::path::Path) -> Result<f32, FactoryError>;
}

// --- Phase 10: The Automaton ---

/// ジョブステータス
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
pub enum JobStatus {
    Pending,
    Processing,
    Completed,
    Failed,
}

impl ToString for JobStatus {
    fn to_string(&self) -> String {
        match self {
            JobStatus::Pending => "Pending".to_string(),
            JobStatus::Processing => "Processing".to_string(),
            JobStatus::Completed => "Completed".to_string(),
            JobStatus::Failed => "Failed".to_string(),
        }
    }
}

impl JobStatus {
    pub fn from_string(s: &str) -> Self {
        match s {
            "Processing" => JobStatus::Processing,
            "Completed" => JobStatus::Completed,
            "Failed" => JobStatus::Failed,
            _ => JobStatus::Pending,
        }
    }
}

/// 永続化ジョブ (The Immortal Schema)
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Job {
    pub id: String,
    pub topic: String,
    pub style: String,
    /// LLM Structured Output (KarmaDirectives) をJSON文字列として格納
    pub karma_directives: Option<String>,
    pub status: JobStatus,
    /// ゾンビタスク回収のための実行開始時刻
    pub started_at: Option<String>,
    /// The Heartbeat Pulse: 長時間レンダリング中のワーカー生存証明
    pub last_heartbeat: Option<String>,
    /// 技術的教訓の自動抽出が完了したか
    pub tech_karma_extracted: bool,
    /// クリエイティブ評価 (人間からの非同期評価): -1=ボツ, 0=普通, 1=最高, None=未評価
    pub creative_rating: Option<i32>,
    /// Log-First Distillation: 実行ログを永続化し、LLMダウン時でも後から蒸留可能にする
    pub execution_log: Option<String>,
    pub error_message: Option<String>,
    // --- Phase 11: World-in-the-Loop SNS Integration ---
    pub sns_platform: Option<String>,
    pub sns_video_id: Option<String>,
    pub published_at: Option<String>,
    /// 多言語出力された動画のリスト (JSON文字列)
    pub output_videos: Option<String>,
}

/// ジョブキュー (The Persistent Memory & Samsara)
///
/// SQLite等を用いた非同期ジョブ管理とKarmaの抽出・記録を行う。
/// The Immortal Schema に準拠。
#[async_trait]
pub trait JobQueue: Send + Sync {
    /// 新規ジョブをキューに追加 (Pending)
    async fn enqueue(&self, topic: &str, style: &str, karma_directives: Option<&str>) -> Result<String, FactoryError>;

    /// 指定したIDのジョブを取得する
    async fn fetch_job(&self, job_id: &str) -> Result<Option<Job>, FactoryError>;

    /// 次に実行すべき Pending ジョブを 1件取得し、Processing に更新
    async fn dequeue(&self) -> Result<Option<Job>, FactoryError>;

    /// ジョブを完了状態にする
    async fn complete_job(&self, job_id: &str, output_videos: Option<&str>) -> Result<(), FactoryError>;

    /// ジョブを失敗状態にする
    async fn fail_job(&self, job_id: &str, reason: &str) -> Result<(), FactoryError>;

    // --- Phase 10-A.5 The Samsara Protocol ---
    /// RAG-Driven Karma Injection: トピックとSkillIDに関連する過去の教訓を抽出する
    async fn fetch_relevant_karma(&self, topic: &str, skill_id: &str, limit: i64, current_soul_hash: &str) -> Result<Vec<String>, FactoryError>;

    /// 抽出された教訓（Karma）を保存する
    /// `karma_type`: 'Technical', 'Creative', 'Synthesized'
    async fn store_karma(&self, job_id: &str, skill_id: &str, lesson: &str, karma_type: &str, soul_hash: &str) -> Result<(), FactoryError>;

    /// The Zombie Hunter: 一定時間以上 Processing のまま放置されたジョブを Failed に強制移行する
    /// Heartbeat 版: last_heartbeat が timeout 分以上途絶えているものを回収
    async fn reclaim_zombie_jobs(&self, timeout_minutes: i64) -> Result<u64, FactoryError>;

    /// クリエイティブ評価 (人間からの非同期フィードバック) を設定する
    async fn set_creative_rating(&self, job_id: &str, rating: i32) -> Result<(), FactoryError>;

    /// The Heartbeat Pulse: 長時間処理中のワーカーが生存を証明する
    async fn heartbeat_pulse(&self, job_id: &str) -> Result<(), FactoryError>;

    /// Log-First Distillation: 実行ログをDBに永続化する（LLMダウン時でも教訓を失わない）
    async fn store_execution_log(&self, job_id: &str, log: &str) -> Result<(), FactoryError>;

    /// Deferred Distillation: ログはあるが Karma 未抽出のジョブを検索する
    async fn fetch_undistilled_jobs(&self, limit: i64) -> Result<Vec<Job>, FactoryError>;

    /// Distillation完了マーク: tech_karma_extracted = 1 にセットする
    async fn mark_karma_extracted(&self, job_id: &str) -> Result<(), FactoryError>;

    /// DB Scavenger: 指定日数以上経過した Completed/Failed ジョブを物理削除する。
    /// karma_logs は `ON DELETE SET NULL` により孤立しても保持される (Eternal Karma)。
    /// 戻り値は削除されたジョブ数。
    async fn purge_old_jobs(&self, days: i64) -> Result<u64, FactoryError>;

    /// SNS動画IDをジョブに紐付ける (Phase 11: The Anchor Link)
    async fn link_sns_data(&self, job_id: &str, platform: &str, video_id: &str) -> Result<(), FactoryError>;

    /// 評価マイルストーンに到達した未評価のジョブを取得する (Phase 11: The Catch-up Logic)
    async fn fetch_jobs_for_evaluation(&self, milestone_days: i64, limit: i64) -> Result<Vec<Job>, FactoryError>;

    /// 取得したSNSメトリクスを台帳に記録する (Phase 11: The Metrics Ledger)
    #[allow(clippy::too_many_arguments)]
    async fn record_sns_metrics(
        &self,
        job_id: &str,
        milestone_days: i64,
        views: i64,
        likes: i64,
        comments_count: i64,
        raw_comments: Option<&str>,
    ) -> Result<(), FactoryError>;

    /// 評価待ち（Oracle未実行）のメトリクス履歴を取得する (Phase 11: Evaluate Phase)
    async fn fetch_pending_evaluations(&self, limit: i64) -> Result<Vec<SnsMetricsRecord>, FactoryError>;

    /// Oracleの評価を適用し、業（Karma）を更新・台帳を完了させる (Phase 11: Commit Phase)
    /// 「台帳の完了」と「業の永続化」を単一トランザクションで行う冪等なアトミック操作。
    async fn apply_final_verdict(
        &self,
        record_id: i64,
        verdict: OracleVerdict,
        soul_hash: &str,
    ) -> Result<(), FactoryError>;

    /// 最近のジョブをN件取得する
    async fn fetch_recent_jobs(&self, limit: i64) -> Result<Vec<Job>, FactoryError>;

    // --- Phase 12: The Agent Evolution (Project Ani) ---
    /// 育成ステータを取得
    async fn get_agent_stats(&self) -> Result<shared::watchtower::AgentStats, FactoryError>;
    /// 親愛度を加算 (Chat対応等)
    async fn add_affection(&self, amount: i32) -> Result<(), FactoryError>;
    /// 技術経験値を加算 (Samsara完了等)
    async fn add_tech_exp(&self, amount: i32) -> Result<(), FactoryError>;
    /// 淫乱度を加算 (R18要素)
    async fn add_intimacy(&self, amount: i32) -> Result<(), FactoryError>;
}

/// 評価台帳（sns_metrics_history）のレコード構造体
#[derive(Debug, Clone)]
pub struct SnsMetricsRecord {
    pub id: i64,
    pub job_id: String,
    pub milestone_days: i64,
    pub views: i64,
    pub likes: i64,
    pub comments_count: i64,
    pub raw_comments_json: Option<String>,
}


/// ログ・通知ツール (FactoryLog)
///
/// 稼働ログをSQLiteに記録し、必要に応じてSlack/Discordに通知する。
#[async_trait]
pub trait FactoryLogger: Send + Sync {
    /// 動画生成成功をログに記録
    async fn log_success(&self, video_id: &str, output_path: &PathBuf) -> Result<(), FactoryError>;

    /// エラーをログに記録
    async fn log_error(&self, reason: &str) -> Result<(), FactoryError>;

    /// 日次サマリーを生成
    async fn daily_summary(&self, _jail: &bastion::fs_guard::Jail) -> Result<String, FactoryError>;
}

/// [法定義] 第1条 & 第2条：物理的境界と通信プロトコル
///
/// すべての AI アクターが遵守すべき基本インターフェース。
/// 物理的なリソースにアクセスする際は、必ず Jail（檻）を介さなければならない。
#[async_trait]
pub trait AgentAct: Send + Sync {
    type Input: serde::Serialize + for<'de> serde::Deserialize<'de> + Send + Clone;
    type Output: serde::Serialize + for<'de> serde::Deserialize<'de> + Send;

    /// 憲法第1条に従い、Jail ハンドルを必須とする実行メソッド
    async fn execute(
        &self,
        input: Self::Input,
        jail: &bastion::fs_guard::Jail,
    ) -> Result<Self::Output, FactoryError>;
}
