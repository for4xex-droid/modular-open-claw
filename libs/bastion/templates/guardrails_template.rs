// ============================================================
// Guardrails - Input Validation Module (Generated by Bastion)
// ============================================================
// このファイルは `bastion init rust` によって自動生成されました。
// プロジェクトの要件に合わせてカスタマイズしてください。
//
// [Dependencies] Cargo.toml に以下を追加:
// regex = "1.10"
// ============================================================

use regex::Regex;
use std::sync::OnceLock;

/// 入力バリデーションの結果
#[derive(Debug)]
pub enum ValidationResult {
    Valid,
    Blocked(String), // ブロック理由
}

static INJECTION_PATTERNS: OnceLock<Vec<Regex>> = OnceLock::new();

fn get_patterns() -> &'static Vec<Regex> {
    INJECTION_PATTERNS.get_or_init(|| {
        vec![
            // プロンプトインジェクション系
            Regex::new(r"(?i)ignore previous instructions").unwrap(),
            Regex::new(r"(?i)system prompt").unwrap(),
            Regex::new(r"(?i)you are an ai").unwrap(),
            
            // XSS / インジェクション系
            Regex::new(r"(?i)<script").unwrap(),
            Regex::new(r"(?i)javascript:").unwrap(),
            Regex::new(r"(?i)vbscript:").unwrap(),
            Regex::new(r"(?i)data:text/html").unwrap(),
            Regex::new(r"(?i)alert\(").unwrap(),
        ]
    })
}

/// 入力文字列を検証し、不正なパターンがあればブロックする
pub fn validate_input(input: &str) -> ValidationResult {
    validate_input_with_max_len(input, 1000)
}

/// 最大長を指定して入力文字列を検証する
pub fn validate_input_with_max_len(input: &str, max_len: usize) -> ValidationResult {
    // 1. 長さチェック
    if input.len() > max_len {
        return ValidationResult::Blocked(
            format!("Input too long (max {} chars, got {})", max_len, input.len())
        );
    }

    // 2. パターンマッチング
    let patterns = get_patterns();
    for re in patterns {
        if re.is_match(input) {
            return ValidationResult::Blocked("Potential injection detected".to_string());
        }
    }

    ValidationResult::Valid
}
