//! # TrendSonar — トレンド収集ツール (Brave Search Integration)
//!
//! 定時でトレンドキーワードを取得する。
//! 外部への通信はすべて reqwest で行い、HTML/URLの除去等の検疫処理（Context Sanitization）を実施する。

use async_trait::async_trait;
use factory_core::contracts::{TrendRequest, TrendResponse};
use factory_core::error::FactoryError;
use factory_core::traits::{AgentAct, TrendItem, TrendSource};
use rig::tool::Tool;
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use regex::Regex;

/// Responses from Brave Web Search API
#[derive(Deserialize, Debug)]
struct BraveSearchResponse {
    web: Option<BraveWebResults>,
}

#[derive(Deserialize, Debug)]
struct BraveWebResults {
    results: Vec<BraveResultItem>,
}

#[derive(Deserialize, Debug)]
struct BraveResultItem {
    description: Option<String>,
}

#[derive(Clone)]
pub struct BraveTrendSonar {
    api_key: String,
    client: reqwest::Client,
}

impl BraveTrendSonar {
    pub fn new(api_key: String) -> Self {
        Self {
            api_key,
            client: reqwest::Client::builder()
                .timeout(std::time::Duration::from_secs(10))
                .build()
                .unwrap_or_else(|_| reqwest::Client::new()),
        }
    }

    /// Context Sanitization: strips HTML tags, excessive whitespace, and URLs
    fn sanitize_snippet(snippet: &str) -> String {
        let mut text = snippet.to_string();
        
        // Strip URLs
        let url_re = Regex::new(r"https?://\S+").unwrap();
        text = url_re.replace_all(&text, "").to_string();
        
        // Strip HTML Tags
        let html_re = Regex::new(r"<[^>]+>").unwrap();
        text = html_re.replace_all(&text, "").to_string();
        
        // Clean up HTML Entities (basic ones)
        text = text.replace("&quot;", "\"")
                   .replace("&amp;", "&")
                   .replace("&lt;", "<")
                   .replace("&gt;", ">")
                   .replace("&#39;", "'");
                   
        // Collapse whitespace
        let ws_re = Regex::new(r"\s+").unwrap();
        text = ws_re.replace_all(&text, " ").to_string();
        
        text.trim().to_string()
    }
}

#[async_trait]
impl TrendSource for BraveTrendSonar {
    async fn get_trends(&self, category: &str) -> Result<Vec<TrendItem>, FactoryError> {
        // Here `category` maps to the actual search query generated by Phase 1 (The Sonar Ping).
        tracing::debug!("BraveTrendSonar: Fetching trends for query '{}'...", category);

        // API-Level Freshness: freshness=pd (Past 24 hours), count=3 to limit noise.
        let res = self.client.get("https://api.search.brave.com/res/v1/web/search")
            .query(&[("q", category), ("freshness", "pd"), ("count", "3")])
            .header("X-Subscription-Token", &self.api_key)
            .header("Accept", "application/json")
            .send()
            .await
            .map_err(|e| FactoryError::Infrastructure { reason: format!("Brave API request failed: {}", e) })?;

        if !res.status().is_success() {
            let status = res.status();
            let body = res.text().await.unwrap_or_default();
            tracing::error!("Brave API Error [{}]: {}", status, body);
            return Err(FactoryError::Infrastructure { reason: format!("Brave API error [{}]: {}", status, body) });
        }

        let search_res: BraveSearchResponse = res.json().await
            .map_err(|e| FactoryError::Infrastructure { reason: format!("Failed to parse Brave API response: {}", e) })?;

        let mut trends = Vec::new();
        if let Some(web) = search_res.web {
            for item in web.results {
                if let Some(desc) = item.description {
                    let sanitized = Self::sanitize_snippet(&desc);
                    if !sanitized.is_empty() {
                        trends.push(TrendItem {
                            keyword: sanitized,
                            source: "BraveSearch".to_string(),
                            score: 1.0, // Base score, could be dynamic
                        });
                    }
                }
            }
        }

        if trends.is_empty() {
            tracing::warn!("BraveTrendSonar: No results found for '{}'", category);
        }

        Ok(trends)
    }
}

#[derive(Deserialize, JsonSchema)]
pub struct TrendArgs {
    pub category: String,
}

#[derive(Serialize)]
pub struct TrendOutput {
    pub trends: Vec<TrendItem>,
}

#[async_trait]
impl AgentAct for BraveTrendSonar {
    type Input = TrendRequest;
    type Output = TrendResponse;

    async fn execute(
        &self,
        input: Self::Input,
        _jail: &bastion::fs_guard::Jail,
    ) -> Result<Self::Output, FactoryError> {
        let trends = self.get_trends(&input.category).await?;
        Ok(TrendResponse { items: trends })
    }
}

impl Tool for BraveTrendSonar {
    const NAME: &'static str = "trend_sonar";
    type Args = TrendArgs;
    type Output = TrendOutput;
    type Error = FactoryError;

    async fn definition(&self, _prompt: String) -> rig::completion::ToolDefinition {
        rig::completion::ToolDefinition {
            name: Self::NAME.to_string(),
            description: "Brave Search APIを用いて、指定されたカテゴリの最新の動向やトレンドキーワードを取得します。".to_string(),
            parameters: serde_json::to_value(schemars::schema_for!(TrendArgs)).unwrap(),
        }
    }

    async fn call(&self, args: Self::Args) -> Result<Self::Output, Self::Error> {
        let trends = self.get_trends(&args.category).await?;
        Ok(TrendOutput { trends })
    }
}

